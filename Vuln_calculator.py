from igraph import *
import tkinter as tk
from tkinter import filedialog
import os

class GraphMaking:



    def __init__(self):
        self.graph = None
        self.contador = 0
        self.order = 0
        self.infinities = []
        self.vuln = []


    def create_graph(self):
        self.graph = Graph()
        root = tk.Tk()
        root.withdraw()
        input_file_path = filedialog.askopenfilename()
        input_file = open(input_file_path)
        connected_vertices = []  # List that contains the pair of connected vertices
        vertices_list = []  # List that contains all the vertices in the graph
        adjacency_list = input_file.readlines()  # Variable that keeps the read file's list.
        for row in adjacency_list:  # Iterate for each row in the read list
            row = row.rstrip('\n')  # Removes the break line character
            for cont, vertex in enumerate(row):  # Iterate for each element (vertex) in the row
                if vertex.isnumeric():  # Makes sure that the element is not a ','
                    if vertex not in vertices_list:  # Verify if the vertex is not on the vertices_list
                        self.graph.add_vertex(vertex)  # Adds the new vertex to the graph
                        vertices_list.append(vertex)  # Adds the new vertex to the vertices_list
                    connected_vertices.append(vertex)  # Adds the vertex to the temporary pair connection list
                if cont == 2:  # It will only enter here after adding both vertices to the graph and/or to the vertices_list
                    self.graph.add_edge(connected_vertices[0],
                                   connected_vertices[1])  # Creates a connection between the pair o vertices
                    connected_vertices.clear()  # Reset the connected_vertices list
        input_file.close()
        self.graph.vs['label'] = vertices_list  # labels the vertices according to the vertices_list
        self.order = self.graph.vcount()
        self.n = self.order







    def global_efficiency(self, g):
        invcam = 0
        self.mencam = g.shortest_paths_dijkstra()                       # Função que retorna o menor caminho entre cada par de vértices do grafo
        # 'If' com o objetivo de manter 'n' constante (pois após remover um vértice n se torna n-1)
        for vertice in self.mencam:                                     # itera para cada vertice de origem na lista de menores caminhos
            for caminho in vertice:                                     # itera para cada destino do vertice de origem em questão
                if caminho != 0:
                    invcam += 1 / caminho                               # Acumula os valores de eficiencia associada a cada par de vértices
        eg = invcam / (self.n * (self.n - 1))
        self.contador += 1
        return eg


    def vulnerability(self):
        # Eficiencia com o vertice
        eg = self.global_efficiency(self.graph)
        # Eficiencia sem o vertice
        for i in range(0, self.order):
            g = self.graph.copy()
            g.delete_vertices(i)
            efi = self.global_efficiency(g)
            v = (eg - efi) / eg

            self.vuln.append(v)


    def isolation(self):
        for i in range (0, self.order):                                                     #for de 0 até a quantidade de vértices, onde cada iteração representa uma rua que ficará inacessível a todas as outras.
            self.acumula_infinito = 0                                                       #Variável que guardará a quantidade de infinitos após as arestas do vértice 'i' ser removida
            graph_copy = self.graph.copy()                                                         #A cada iteração a varoável 'graf' receberá a cópia do grafo original
            del_list = []                                                                   #lista que conterá os ids das arestas do vértice 'i' que serão removidas.
            for target_vertex_id in range(0, self.order):
                try:
                    del_list.append(graph_copy.get_eid( i, target_vertex_id))                     #função que captura o id da aresta pertencente ao par de vértices (i, target_vertex_id), e acrescenta na lista 'del_list'
                except:
                    pass                                                                    #caso o id não exista
            graph_copy.delete_edges(del_list)                                                      #deleta as arestas contidas na lista 'del_list'
            self.mencam = graph_copy.shortest_paths_dijkstra()                                     #cria lista com todos os menores caminhos para de/para todos os vértices
            for vertice in self.mencam:                                                         # itera para cada vertice de origem na lista de menores caminhos
                self.acumula_infinito += vertice.count(float('inf'))                            # Guarda as ruas inacessiveis para um determinado vértice quando ele é removido
            self.infinities.append(self.acumula_infinito)                                      #dicionário que guarda em cada posição a quantidade de infinitos relacionados ao isolamento da rua 'i'.


    def create_results(self):
        output_file_path = filedialog.asksaveasfile(mode='w', defaultextension='.txt')
        output_file = open(output_file_path.name, 'a')
        output_file.write('Id, vuln, isolation\n')
        for i in range(0, grp.order):
            output_file.write(str(i) + ', ' + str(grp.vuln[i]) + ', ' + str(grp.infinities[i]) + '\n')



grp = GraphMaking()
grp.create_graph()
grp.vulnerability()
grp.isolation()
grp.create_results()




