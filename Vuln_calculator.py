## AUTHOR: JEFERSON FEITOSA MENDES

from igraph import *


class GraphMaking:

    def __init__(self):
        self.graph = None
        self.order = 0
        self.vulnerabilities = []
        self.global_efficiencies = []

    def create_graph(self):
        self.graph = Graph()
        input_file = open('input.txt', 'r')
        self.vertices_list = []  # List that contains all the vertices of the graph
        adjacency_list = input_file.readlines()  # holds the read file's list.
        for row in adjacency_list:  # Iterate for each row in the read list
            row = row.rstrip('\n')  # Removes the break line character
            try:
                v1, v2 = row.split(',') #Temporary vavriables to get each node of the input line
                if v1 not in self.vertices_list:  # Verifies if the node is not on the vertices_list
                    self.graph.add_vertex(v1)  # Adds the new vertex to the graph
                    self.vertices_list.append(v1)  # Adds the new vertex to the vertices_list
                if v2 not in self.vertices_list:
                    self.graph.add_vertex(v2)  # Adds the new vertex to the graph
                    self.vertices_list.append(v2)  # Adds the new vertex to the vertices_list
                self.graph.add_edge(v1, v2)  # Creates a connection between the pair o vertices
            except: #if there there's only one vertice in the input line
                v1 = row[0:] #v1 will be that value
                if v1 not in self.vertices_list:  # Verify if the vertex is not on the vertices_list
                    self.graph.add_vertex(v1)  # Adds the new vertex to the graph
                    self.vertices_list.append(v1)  # Adds the new vertex to the vertices_list

        input_file.close()
        self.graph.vs['label'] = self.vertices_list  # labels the vertices according to the vertices_list
        self.order = self.graph.vcount()
        self.n = self.order

    def global_efficiency(self, g):
        invcam = 0
        self.shortest_paths = g.shortest_paths_dijkstra()  #returns a list with all shortest paths from each vertex
        for vertex_paths in self.shortest_paths:
            for shortest_path in vertex_paths: #iterates on each single shortest path
                if shortest_path != 0:
                    invcam += 1 / shortest_path  #acumulates the efficiency of each pair of nodes
        eg = invcam / (self.n * (self.n - 1)) # Calculates global efficiency
        self.global_efficiencies.append(eg)
        return eg

    def vulnerability(self):
        # Eficiencia com o vertice
        eg = self.global_efficiency(self.graph)
        # Eficiencia sem o vertice
        for i in range(0, self.order): #iterating for all vertices
            g = self.graph.copy()  # makes a copy of the original graph
            del_list = []  # lista que conterá os ids das arestas do vértice 'i' que serão removidas.
            for target_vertex_id in range(0, self.order):
                try:
                    del_list.append(g.get_eid(i,target_vertex_id))  #Gets the id of the edge that belongs to the pair of vertices(i,target_vertex_id) and puts it in 'del_list'
                except:
                    pass  # In case the id does not exist
            g.delete_edges(del_list) #deletes all edges of connected to the vertex i
            efi = self.global_efficiency(g) #gets the efficiency
            v = (eg - efi) / eg #calculates vulnerability
            self.vulnerabilities.append(v)

    def create_results(self):
        output_global = open('output_global.txt', 'w')
        output_local = open('output_local.txt', 'a')
        output_global.write('Order, Original_Efficiency, \n' + str(self.order) + ',' + str(self.global_efficiencies[0]))
        output_local.write('vertice'+':'+'vulnerability_index \n')
        for i in range(0, grp.order):
            output_local.write(str(self.vertices_list[i]) +',' + str(self.vulnerabilities[i]) + '\n')

grp = GraphMaking()
grp.create_graph()
grp.vulnerability()
grp.create_results()
